Java并发包&线程池原理分析&锁的深度化


什么线程安全问题？

保证在多个线程之间共享同个全局变量或静态变量,保证数据一致性、和原子性

线程同步有哪些方式？
synchronized、lock

线程同步提高了效率吗？

降低程序效率、阻塞、抢锁的资源、效率并不高

 
Java并发包
第一节
  Vector与ArrayList区别和HashTable与HashMap线程安全源码分析


1、Vector与ArrayList区别???
实现原理都是通过数组实现-查询速度快，增加、修改、删除速度慢
区别: 线程安全问题
Vector是安全（上锁的集合）、ArrayList线程不安全 ArrayList效率高


Vector集合的add方法加了同步函数，加了synchronized关键字,但是ArrayList集合add方法没有加任何同步的,也没有用到任何lock锁,所以线程是不安全的


答:1.ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。
2.Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢

2、HashTable与HashMap区别？
两者都是链表+数组 put HashCode取模得到下表位置 一致性取模算法


1.HashMap不是线程安全的 
HastMap是一个接口 是map接口的子接口，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap允许null key和null value，而hashtable不允许。
2.HashTable是线程安全的一个Collection。
3.HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey.注意: HashTable线程安全，HashMap线程不安全


3、synchronizedMap
Collections.synchronized*(m) 将线程不安全额集合变为线程安全集合

4、ConcurrentHashMap
ConcurrentMap接口下有俩个重要的实现 : ConcurrentHashMap ConcurrentskipListMap (支持并发排序功能。弥补ConcurrentHas hMa p) ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个 小的HashTable,它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并 发进行。把一个整体分成了16个段(Segment.也就是最高支持16个线程的并发修改操作。 这也是在重线程场景时减小锁的粒度从而降低锁竞争的一种方案。并且代码中大多共享变 量使用volatile关键字声明，目的是第一时间获取修改的内容，性能非常好。
